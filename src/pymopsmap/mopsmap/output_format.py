"""
mospmap_output_format.py

Author  : KÃ©vin Walcarius
Date    : 2026-01-08
Version : 1.0
License : MIT
Summary : Module used to format the outputs (stdout and output.nc)
          generated by Mopsmap.
"""

from pathlib import Path
from typing import Any
import xarray as xr
import numpy as np
from pymopsmap.classes import OptiProps


def format_mopsmap_outputs(out_mopsmap: dict[str, Any]) -> OptiProps:
    """
    Build a single OptiProps containing:
      - spectral vars from stdout: (wl)
      - phase from netcdf: phase(wl, mueller_idx, theta)

    wl is ALWAYS taken from stdout and enforced onto phase coords.
    """
    ds_stdout = format_stdout(out_mopsmap["stdout"])
    wl = ds_stdout["wl"].values

    ds_phase = format_netcdf_file(out_mopsmap["output_path"], wl=wl)

    ds = xr.merge(
        [ds_stdout, ds_phase[["phase"]]],
        compat="no_conflicts",
        join="outer",
    )
    return OptiProps(ds=ds)


def format_stdout(stdout: str) -> xr.Dataset:
    """
    Parse MOPSMAP stdout blocks split by "integrated" into a Dataset with
    dimension (wl). Expected number of columns (12):

      (
        wl, kext, ssa, g, reff, n,
        cross_dens, vol_dens, mass_conc,
        angstrom_ext, angstrom_sca, angstrom_abs
      )

    The output is returned as an xarray dataset.
    """
    blocks = stdout.split("integrated")

    rows: list[np.ndarray] = []
    for blk in blocks[1:]:
        toks = blk.strip().split()
        if not toks:
            continue
        rows.append(np.asarray(toks, dtype=np.float32))

    if not rows:
        raise ValueError(
            "No numeric data found in stdout (split by 'integrated')."
        )

    arr = np.stack(rows, axis=0)  # (n_wl, 12)
    wl = arr[:, 0].astype(np.float32)

    return xr.Dataset(
        data_vars={
            "kext": (("wl",), arr[:, 1]),
            "ssa": (("wl",), arr[:, 2]),
            "g": (("wl",), arr[:, 3]),
            "reff": (("wl",), arr[:, 4]),
            "n": (("wl",), arr[:, 5]),
            "cross_dens": (("wl",), arr[:, 6]),
            "vol_dens": (("wl",), arr[:, 7]),
            "mass_conc": (("wl",), arr[:, 8]),
            "angstrom_ext": (("wl",), arr[:, 9]),
            "angstrom_sca": (("wl",), arr[:, 10]),
            "angstrom_abs": (("wl",), arr[:, 11]),
        },
        coords={"wl": wl},
    )


def format_netcdf_file(filename: Path, wl: np.ndarray) -> xr.Dataset:
    """
    Parse output.nc and return a Dataset containing:
      - phase(wl, mueller_idx, theta)

    IMPORTANT: wl coord is enforced from the provided `wl` (coming from stdout).
    """
    xrds = xr.open_dataset(filename)
    if "nreff" in xrds.dims:
        xrds = xrds.isel(nreff=0)

    if "phase" not in xrds:
        raise KeyError("Variable 'phase' not found in netCDF file.")

    # theta grid (as you did before)
    theta = np.linspace(
        0.0, 180.0, len(xrds.nthetamax.data), dtype=np.float32
    )[::-1]

    wl = np.asarray(wl, dtype=np.float32)

    phase = np.asarray(xrds["phase"].data, dtype=np.float32)
    if phase.ndim != 3:
        raise ValueError(f"'phase' must be 3D, got shape {phase.shape}.")

    # Accept (wl, mueller, theta) or (mueller, wl, theta)
    if phase.shape[0] == wl.size:
        pass  # already (wl, mueller, theta)
    elif phase.shape[1] == wl.size:
        phase = phase.transpose(1, 0, 2)  # -> (wl, mueller, theta)
    else:
        raise ValueError(
            f"Cannot align phase with wl from stdout: wl.size={wl.size}, phase.shape={phase.shape}."
        )

    mueller_idx = np.arange(phase.shape[1], dtype=np.int32)

    return xr.Dataset(
        data_vars={"phase": (("wl", "mueller_idx", "theta"), phase)},
        coords={"wl": wl, "mueller_idx": mueller_idx, "theta": theta},
    )
